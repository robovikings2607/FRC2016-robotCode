Testing to do:
1) boot up with arm lowered; verify arm positioning works with new driver class
	a) run arm up; when up it shouldn't go up again
	b) run arm down; when down it shouldn't go down again 
2) change code to use an array of absolute positions rather than rotating by angle
	a) fully test, including pushing up while arm is already moving up (should have no effect, 
	just finish original profile)
3) test arm homing procedure 
	a) boot up with arm up; verify can't move arm in teleop;  verify homing works
			- initially, stop homing early by triggering switch;  after confirming that works, reboot with 
			arm up and run full homing procedure
	b) after homing verify arm positioning works
4) confirm that disabling and re-enabling is safe (e.g. transition from auto to teleop)
	a) with winder homing in progress, disable and re-enable;  shooter should resume and complete homing, and end 
	up enabled (able to shoot)
	b) with re-cock sequence in progress, disable and re-enable;  shooter should resume and complete sequence, and 
	end up able to shoot	 
	c) with arm homing in progress, disable.  Should see abort message on console
		1) upon re-enabling, arm should stay disabled and wait to operator to re-initiate homing
	d) with arm MP in progress, disable
		1) upon re-enabling, arm should stay in current position and you should be able to move as normal (profile
		should handle current position)
4) position PID tuning for drive train
	a) run from autonomous rather than test to keep it simple and verify no unexpected wierdness	

CompBot 2016 Control Scheme

Driver Controls
	self-explanatory
		- left stick Y axis is forward/reverse, right stick X axis is left/right turn
	right stick button is shift
		- code defaults to high gear (solenoid set to true on init) 
	
Operator Controls follow MikeyBear's Dream Control Scheme 

	Shoot and re-cock shooter - Right Trigger
		- controller will rumble if you try to shoot and claw isn't opened
	Lock the shooter		  - Left Trigger
	Left and Right Bumpers - Rollers in and out
  	Up and down on D-Pad - move arm up and down
	Toggle Claw open/closed	- Button B
	
		Start button:  press and hold to execute shooter homing procedure....
			- needs to be run if robot booted with shooter not fully cocked
			- only runs if shooter's not enabled
			- if you release the start button before the shooter reaches home, it'll abort and you have to re-run
			
Maintenance Controls (Test Mode)

	Right Bumper (6) - tighten winder (motor spins reverse/negative voltage; encoder position decreases)
	Left Bumper (5) - loosen winder (motor spins forward/positive voltage; encoder position increases)

	Left Trigger (axis 2) - lock the puncher 
	Right Trigger (axis 3) - shoot the puncher 

	Button A (1) - lower the arm 5 degrees
	Button Y (4) - lift the arm 5 degrees

	Button B (2) - Toggle claw open/close
	
TODO:
1) Need to determine start-up procedure for field
	- when powered off arm will fall if below ~45deg (gravity)
	- need external sensor to detect raised position, and assume on power up if that switch doesn't detect the
	arm, that the arm is at it's lowest position
		- can try setting soft limit to that position and see how it works, think we need to reset arm
		motion profiles (i.e. call PuncherArm.resetArm()) if the soft limit fault occurs, and possibly
		clear it, before any other profiels will run
		- check with Omar on expected behavior

	- tested setting and clearing faults;  JNI methods not implemented for reading SRX faults so robot code
	crashes.  Therefore can't use these, and will have to eliminate the forward soft limit eventually
	- will need to try using just VBUS with low command	to move to 0 position

	UPDATE:
		- implemented ArmHomingThread, need to decide how to fire it (the oContoller back button?)
			- only fire if arm control is disabled, obviously
	 
2) Plan and code autonomous routine for HH (low bar, turn, shoot)
	- on-the-fly profile generation and execution now works for the drive train, however generation is 
	time-consuming, and just controlling the wheel velocities doesn't give accurate enough travel
	- need to:
		- incorporate execution of profiles generated & serialized offline
		- incorporate and tune position PID with Kv feed-forward (RobovikingModPIDController)
			- profiles will all be relative to where we start, so just need to reset drive encoder positions
			at start of profile

3) Add TCP code (or user network tables) for data exchange with vision app

4) (?) add slow speed for rollers so centering the ball is easier (just a small "tap" outwards of the roller) (?)

5) refactor SRXProfileDriver as a thread, and wait for Talon to report that it's MPE state is disabled before
pushing new profile - the example driver from Omar doesn't do this, but per his response to my question it's
proper procedure to wait until the Talon reports it's MPE state as disabled before pushing new points
	- with driver as a thread we don't have to call the driver control() (arm.process()) from teleopPeriodic 
	(or autonomousPeriodic)

6) add power logger/monitor to drive train

7) update winder logger to record process step, power, encoder, etc to use to diagnose failure and see if we can
detect based on current draw when it's pushing the plunger (see below)

8) ? check for winder stall as a protection against over driving when moving up to grab plunger?
	- stall is probably too late actually....check current being drawn normally, and watch for spike which would
	indicate it's started pushing the plunger up?
	- check encoder position during movement for consistency? (i.e. position delta should stay pretty consistent)

	 
Arm Positioning:
	Talon encoder provides count of cim motor revs, forward >0, reverse <0
		encoder is reversed, so must use CANTalon.reverseSensor(true) to keep encoder and motor in phase
		(i.e. postive voltage causes position to increase, negative voltage cause position to decrease)

	Forward (postive) voltage cause gearbox output to spin counter-clockwise when you look at it head on; or in other words
		if you're looking at a side view with the cim to the left and the shaft to the right, forward means shaft spins towards you
	
	Motor is mounted on left of arm and attached via an addition gear, so therefore:
		Forward (positive) voltage will rotate arm towards front of robot (down) 
		Reverse (negative) voltage will rotate arm towards rear of robot  (up)
		
	350 cim revs equates to 360deg of arm travel:  i.e. deg/rev = 360/350
	so, to travel Xdeg, number of revs required is ((350 * Xdeg) / 360)

	let currentArmPos = rotations up from 0 (bottom);  is therefore always <= 0 when arm is not "home"
		- remember, running motor in reverse raises the arm, forward lowers the arm

	if we have a set of known positions (in # of negative rotations), we
	can generate a profile to take us from current position to selected target
	- e.g. start at 0, rotate to position -47 (move arm up)
		- total distance is -47 (-(current - target))
	
	- start at position -47, rotate to position -20 (move arm down)
		- total distance is 27 = (-(current - target)) 
		= (-(-47 -(-20))) 
		= -(-47 + 20) 
		= -(-27)
		= 27
		
	- start at position -20, rotate to position -47 (move arm up)
		= -(-20 -(-47))
		= -(-20 + 47)
		= -(27)

	- start at position 0, rotate to position -47 (move arm up)
		= -(0 - (-47))
		= -(47)

	- start at position -47, rotate to position 0 (move arm down)
		= -(-47 - 0)
		= -(-47)
		
	arm start-up:
		- if photoeye is true, that means the arm is not fully down;  arm position control needs to stay disabled
		
	an example for converting from a vision angle: given that forward motor travel rotates arm towards front, measure like a protractor:  
		Consider 90deg as straight up, 180 as flat pointing out the front of the robot, and 0 as flat pointing out the rear
		of the robot 	
		Have vision targeting report target angle between 90 and 180;  e.g. subtract triangulated aim angle from 180
		
	To calculate degrees to travel to change aim:
		subtract current angle from target angle, and travel that far in that direction
	
	For example:
		current angle is 90deg, target angle is 110deg (70deg elevation pointing out front of robot)
			travelDegrees = 110 - 90 = 20deg
		current angle is 110, target angle is 70deg (70deg elevation pointing out back of robot)
			travelDegrees = 70 - 110 = -40deg  
	
	soft limits in Talon don't provide for reliable protection when used with MPE:
		- if position is relative and is reset on each profile, obviously the limits would never be
		triggered
		- if using absolute position and not resetting on each profile, the MPE seems to go wonky 
		when a limit is tripped
			- with limit fault tripped, the next profile in the opposite direction doesn't run; need
			to send it twice
			- there's no way in Java to poll the fault, the WPI methods currently return JNI exceptions
			which crashes the robot code

	see about detecting stall to protect against lowering too far (hitting frame / floor)
		
	42 degrees is the optimal angle for shooting into the high goal from the edge of the outer works
	
	
	
	
	 	
	