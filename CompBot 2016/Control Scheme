CompBot 2016 Control Scheme

Driver Controls
	self-explanatory
		- left stick Y axis is forward/reverse, right stick X axis is left/right turn
	right stick button is shift
		- code defaults to high gear (solenoid set to true on init) 
	
Operator Controls follow MikeyBear's Dream Control Scheme 

[DONE]	Shoot and Lock Piston and open the claw - Right Trigger
[DONE]	Left and Right Bumpers - Rollers in and out
[DONE]  Up and down on D-Pad - move arm up and down

Maintenance Controls (Test Mode)

	Right Bumper (6) - tighten winder (motor spins reverse/negative voltage; encoder position decreases)
	Left Bumper (5) - loosen winder (motor spins forward/positive voltage; encoder position increases)

	Left Trigger (axis 2) - lock the puncher 
	Right Trigger (axis 3) - shoot the puncher 

	Button A (1) - lower the arm 5 degrees
	Button Y (4) - lift the arm 5 degrees

	Button B (2) - Toggle claw open/close
	
TODO:
1) Need to determine start-up procedure for field
	- when powered off arm will fall if below ~45deg (gravity)
	- need external sensor to detect raised position, and assume on power up if that switch doesn't detect the
	arm, that the arm is at it's lowest position
		- can try setting soft limit to that position and see how it works, think we need to reset arm
		motion profiles (i.e. call PuncherArm.resetArm()) if the soft limit fault occurs, and possibly
		clear it, before any other profiels will run
		- check with Omar on expected behavior

	- tested and clearing faults;  JNI methods not implemented for reading SRX faults so robot code
	crashes.  Therefore can't use these, and will have to eliminate the forward soft limit eventually
	- will need to try using just velocity PID (with feedforward only) or VBUS with low command 
	to move to 0 position
	 

2) Add TCP code (or user network tables) for data exchange with vision app

3) Plan and code autonomous routine for HH (low bar, turn, shoot)

4) (?) add slow speed for rollers so centering the ball is easier (just a small "tap" outwards of the roller) (?)

5) refactor SRXProfileDriver as a thread, and wait for Talon to report that it's MPE state is disabled before
pushing new profile - the example driver from Omar doesn't do this, but per his response to my question it's
proper procedure to wait until the Talon reports it's MPE state as disabled before pushing new points
	- with driver as a thread we don't have to call the driver control() (arm.process()) from teleopPeriodic 
	(or autonomousPeriodic)

6) add PDP logger/monitor
	- drive train?

7) ? check for winder stall as a protection against over driving when moving up to grab plunger?
	- stall is probably too late actually....check current being drawn normally, and watch for spike which would
	indicate it's started pushing the plunger up?
	- check encoder position during movement for consistency? (i.e. position delta should stay pretty consistent)

8) drive train position PID tuning
	- separate project for this to keep things simple

	 
Arm Positioning:
	Talon encoder provides count of cim motor revs, forward >0, reverse <0
		encoder is reversed, so must use CANTalon.reverseSensor(true) to keep encoder and motor in phase
		(i.e. postive voltage causes position to increase, negative voltage cause position to decrease)

	Forward (postive) voltage cause gearbox output to spin counter-clockwise when you look at it head on; or in other words
		if you're looking at a side view with the cim to the left and the shaft to the right, forward means shaft spins towards you
	
	Motor is mounted on left of arm and attached via an addition gear, so therefore:
		Forward (positive) voltage will rotate arm towards front of robot 
		Reverse (negative) voltage will rotate arm towards rear of robot	
		
	350 cim revs equates to 360deg of arm travel:  i.e. deg/rev = 360/350
	so, to travel Xdeg, number of revs required is ((350 * Xdeg) / 360)

	given that forward motor travel rotates arm towards front, measure like a protractor:  
		Consider 90deg as straight up, 180 as flat pointing out the front of the robot, and 0 as flat pointing out the rear
		of the robot 	
		Have vision targeting report target angle between 90 and 180;  e.g. subtract triangulated aim angle from 180
		
	To calculate degrees to travel to change aim:
		subtract current angle from target angle, and travel that far in that direction
	
	For example:
		current angle is 90deg, target angle is 110deg (70deg elevation pointing out front of robot)
			travelDegrees = 110 - 90 = 20deg
		current angle is 110, target angle is 70deg (70deg elevation pointing out back of robot)
			travelDegrees = 70 - 110 = -40deg  
	
	can't use soft limits in Talon for protection since position is relative and is reset on each profile
		see about detecting stall to protect against lowering too far (hitting frame / floor)
		
	42 degrees is the optimal angle for shooting into the high goal from the edge of the outer works
	
	
	
	
	 	
	